<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>EfficientNet - Compound Scaling | ASR</title>
<meta name="keywords" content="Deep Learning, Neural Networks, CNN, EfficientNet">
<meta name="description" content="Explore the EfficientNet architecture and its innovative compound scaling.">
<meta name="author" content="">
<link rel="canonical" href="https://adilsarsenov.dev/posts/effnet/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.a72801f0f40a8d7f71aa1cafd1c2f2a993a1f26ca1cfd38fdba65d5b9b0f08a0.css" integrity="sha256-pygB8PQKjX9xqhyv0cLyqZOh8myhz9OP26ZdW5sPCKA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://adilsarsenov.dev/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://adilsarsenov.dev/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://adilsarsenov.dev/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://adilsarsenov.dev/apple-touch-icon.png">
<link rel="mask-icon" href="https://adilsarsenov.dev/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="EfficientNet - Compound Scaling" />
<meta property="og:description" content="Explore the EfficientNet architecture and its innovative compound scaling." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://adilsarsenov.dev/posts/effnet/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-23T18:34:44&#43;05:00" />
<meta property="article:modified_time" content="2024-03-23T18:34:44&#43;05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="EfficientNet - Compound Scaling"/>
<meta name="twitter:description" content="Explore the EfficientNet architecture and its innovative compound scaling."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://adilsarsenov.dev/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "EfficientNet - Compound Scaling",
      "item": "https://adilsarsenov.dev/posts/effnet/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "EfficientNet - Compound Scaling",
  "name": "EfficientNet - Compound Scaling",
  "description": "Explore the EfficientNet architecture and its innovative compound scaling.",
  "keywords": [
    "Deep Learning", "Neural Networks", "CNN", "EfficientNet"
  ],
  "articleBody": "Introduction EfficientNet is an advanced deep learning model introduced by Mingxing Tan and Quoc V. Le from Google Research, Brain team, in their paper “EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks”. EfficientNet solves the common problem of balancing accuracy and resource consumption in deep learning models by using a novel technique called compound scaling.\nWhy EfficientNet? The Challenge of Traditional Models Traditional deep learning models often face a trade-off between accuracy and resource use. Making a model more accurate usually means making it larger, which requires more computational power and memory. EfficientNet tackles this challenge effectively.\nThe Solution: Compound Scaling EfficientNet introduces compound scaling, which scales three critical dimensions of a neural network: width, depth, and resolution. This scaling method ensures that the model is both efficient and accurate.\nWidth Scaling Width scaling refers to the number of channels(third dimension of an image) in each layer of the neural network. Increasing the width helps the model capture more complex patterns and features, leading to improved accuracy. Conversely, decreasing the width results in a more lightweight model suitable for environments with limited resources.\nDepth Scaling Depth scaling involves the total number of layers in the network. Deeper models can capture more intricate data representations but require more computational resources. Shallower models are computationally efficient but might sacrifice accuracy.\nResolution Scaling Resolution scaling adjusts the size of the input images. Higher-resolution images provide more detailed information, potentially improving performance. However, they also need more memory and computational power. Lower-resolution images consume fewer resources but may lose fine-grained details.\nMathematical Explanation of Compound Scaling EfficientNet uses a simple yet effective method to scale up models. The scaling method is guided by a compound coefficient $( \\phi )$ which uniformly scales network width, depth, and resolution:\n$$\n\\text{depth:} \\quad d = \\alpha^\\phi $$\n$$\n\\text{width:} \\quad w = \\beta^\\phi $$\n$$\n\\text{resolution:} \\quad r = \\gamma^\\phi $$\nwhere $( \\alpha )$, $( \\beta )$, and $( \\gamma )$ are constants determined through a small grid search and $( \\phi )$ is a user-specified coefficient that controls how much to scale each dimension. The idea is to balance all three dimensions rather than scaling one aspect alone.\nGrid Search for EfficientNet The process of determining the constants $( \\alpha )$, $( \\beta )$, and $( \\gamma )$ involves two main steps:\nStep 1: Baseline Network Assume twice the resources are available and set $( \\phi = 1 )$. Perform a small grid search for $( \\alpha )$, $( \\beta )$, and $( \\gamma )$ based on equations 2 and 3 from the original paper. Specifically, the best values for EfficientNet-B0 are found to be $( \\alpha = 1.2 )$, $( \\beta = 1.1 )$, and $( \\gamma = 1.15 )$ under the constraint:\n$$\n\\alpha \\cdot \\beta^2 \\cdot \\gamma^2 \\approx 2 $$\nStep 2: Compound Scaling Fix $( \\alpha )$, $( \\beta )$, and $( \\gamma )$ as constants and scale up the baseline network with different $( \\phi )$ values using the equation:\n$$\n\\text{New Depth} = \\alpha^\\phi \\times \\text{Baseline Depth} $$\n$$\n\\text{New Width} = \\beta^\\phi \\times \\text{Baseline Width} $$\n$$\n\\text{New Resolution} = \\gamma^\\phi \\times \\text{Baseline Resolution} $$\nThis method is used to obtain EfficientNet-B1 up to B7 models.\nEfficientNet Architecture EfficientNet uses Mobile Inverted Bottleneck (MBConv) layers, which combine depth-wise separable convolutions and inverted residual blocks. This architecture helps achieve high performance with fewer resources.\nInverted Residual Blocks(aka MBConv Block) Layers: EfficientNet uses these layers for efficient feature extraction. Compound Scaling: Scales width, depth, and resolution uniformly. Inside an Inverted Residual Block:\n1x1 Convolution (Expansion): Expands the number of channels. Depthwise Convolution: Applies lightweight filters to each channel independently. Squeeze-and-Excitation (SE): Assigns importance weights to each channel. 1x1 Convolution (Projection): Reduces the number of channels back to the original size. Residual Connection: Adds the original input back to the output. EfficientNet models have set new benchmarks for accuracy while being more resource-efficient than previous models. They are widely used for various computer vision tasks due to their balanced approach to scaling. Their architectures, such as EfficientNet-B0 up to EfficientNet-B7, provide a range of options depending on the required accuracy and available computational resources. ",
  "wordCount" : "693",
  "inLanguage": "en",
  "datePublished": "2024-03-23T18:34:44.165668+05:00",
  "dateModified": "2024-03-23T18:34:44.165668+05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://adilsarsenov.dev/posts/effnet/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ASR",
    "logo": {
      "@type": "ImageObject",
      "url": "https://adilsarsenov.dev/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top"><script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header sticky-header">
    <nav class="nav">
        <div class="logo">
            <a href="https://adilsarsenov.dev/" accesskey="h" title="ASR (Alt + H)">ASR</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://adilsarsenov.dev/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://adilsarsenov.dev/posts" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://adilsarsenov.dev/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://adilsarsenov.dev/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://adilsarsenov.dev/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://adilsarsenov.dev/">Home</a>&nbsp;»&nbsp;<a href="https://adilsarsenov.dev/posts/">Posts</a></div>
    <h1 class="post-title">
      EfficientNet - Compound Scaling
    </h1>
    <div class="post-description">
      Explore the EfficientNet architecture and its innovative compound scaling.
    </div>
    <div class="post-meta">


Date: 23 March, 2024

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">‎ Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#why-efficientnet" aria-label="Why EfficientNet?">Why EfficientNet?</a><ul>
                        
                <li>
                    <a href="#the-challenge-of-traditional-models" aria-label="The Challenge of Traditional Models">The Challenge of Traditional Models</a></li></ul>
                </li>
                <li>
                    <a href="#the-solution-compound-scaling" aria-label="The Solution: Compound Scaling">The Solution: Compound Scaling</a><ul>
                        
                <li>
                    <a href="#width-scaling" aria-label="Width Scaling">Width Scaling</a></li>
                <li>
                    <a href="#depth-scaling" aria-label="Depth Scaling">Depth Scaling</a></li>
                <li>
                    <a href="#resolution-scaling" aria-label="Resolution Scaling">Resolution Scaling</a></li></ul>
                </li>
                <li>
                    <a href="#mathematical-explanation-of-compound-scaling" aria-label="Mathematical Explanation of Compound Scaling">Mathematical Explanation of Compound Scaling</a><ul>
                        
                <li>
                    <a href="#grid-search-for-efficientnet" aria-label="Grid Search for EfficientNet">Grid Search for EfficientNet</a><ul>
                        
                <li>
                    <a href="#step-1-baseline-network" aria-label="Step 1: Baseline Network">Step 1: Baseline Network</a></li>
                <li>
                    <a href="#step-2-compound-scaling" aria-label="Step 2: Compound Scaling">Step 2: Compound Scaling</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#efficientnet-architecture" aria-label="EfficientNet Architecture">EfficientNet Architecture</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h3>
<p>EfficientNet is an advanced deep learning model introduced by <strong>Mingxing Tan and Quoc V. Le from Google Research, Brain team,
in their paper &ldquo;EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks&rdquo;</strong>. EfficientNet solves the common problem of balancing accuracy and resource consumption in deep learning models by using a novel technique called <strong>compound scaling</strong>.</p>
<h3 id="why-efficientnet">Why EfficientNet?<a hidden class="anchor" aria-hidden="true" href="#why-efficientnet">#</a></h3>
<h4 id="the-challenge-of-traditional-models">The Challenge of Traditional Models<a hidden class="anchor" aria-hidden="true" href="#the-challenge-of-traditional-models">#</a></h4>
<p>Traditional deep learning models often face a trade-off between accuracy and resource use. Making a model more accurate usually means making it larger, which requires more computational power and memory. EfficientNet tackles this challenge effectively.</p>
<h3 id="the-solution-compound-scaling">The Solution: Compound Scaling<a hidden class="anchor" aria-hidden="true" href="#the-solution-compound-scaling">#</a></h3>
<p>EfficientNet introduces compound scaling, which scales three critical dimensions of a neural network:
<strong>width, depth, and resolution</strong>. This scaling method ensures that the model is both efficient and accurate.</p>
<p><img loading="lazy" src="/posts/effnet/img1.png" alt="EfficientNet"  />
</p>
<h4 id="width-scaling">Width Scaling<a hidden class="anchor" aria-hidden="true" href="#width-scaling">#</a></h4>
<p>Width scaling refers to the number of channels(<strong>third dimension of an image</strong>) in each layer of the neural network.
Increasing the width helps the model capture more complex patterns and features, leading to improved accuracy.
Conversely, decreasing the width results in a more lightweight model suitable for environments with limited resources.</p>
<h4 id="depth-scaling">Depth Scaling<a hidden class="anchor" aria-hidden="true" href="#depth-scaling">#</a></h4>
<p>Depth scaling involves the <strong>total number of layers</strong> in the network.
Deeper models can capture more intricate data representations but require more computational resources.
Shallower models are computationally efficient but might sacrifice accuracy.</p>
<h4 id="resolution-scaling">Resolution Scaling<a hidden class="anchor" aria-hidden="true" href="#resolution-scaling">#</a></h4>
<p>Resolution scaling <strong>adjusts the size of the input images</strong>.
Higher-resolution images provide more detailed information, potentially improving performance.
However, they also need more memory and computational power. Lower-resolution images consume fewer resources but may lose fine-grained details.</p>
<h3 id="mathematical-explanation-of-compound-scaling">Mathematical Explanation of Compound Scaling<a hidden class="anchor" aria-hidden="true" href="#mathematical-explanation-of-compound-scaling">#</a></h3>
<p>EfficientNet uses a simple yet effective method to scale up models. The scaling method is guided by a compound coefficient $( \phi )$ which uniformly scales network width, depth, and resolution:</p>
<p>$$<br>
\text{depth:} \quad d = \alpha^\phi
$$</p>
<p>$$<br>
\text{width:} \quad w = \beta^\phi
$$</p>
<p>$$<br>
\text{resolution:} \quad r = \gamma^\phi
$$</p>
<p>where $( \alpha )$, $( \beta )$, and $( \gamma )$ are constants determined through a <strong>small grid search</strong> and $( \phi )$ is a user-specified coefficient that controls how much to scale each dimension.
<strong>The idea is to balance all three dimensions rather than scaling one aspect alone</strong>.</p>
<h4 id="grid-search-for-efficientnet">Grid Search for EfficientNet<a hidden class="anchor" aria-hidden="true" href="#grid-search-for-efficientnet">#</a></h4>
<p>The process of determining the constants $( \alpha )$, $( \beta )$, and $( \gamma )$ involves two main steps:</p>
<h5 id="step-1-baseline-network">Step 1: Baseline Network<a hidden class="anchor" aria-hidden="true" href="#step-1-baseline-network">#</a></h5>
<p>Assume twice the resources are available and set $( \phi = 1 )$. Perform a small grid search for $( \alpha )$, $( \beta )$, and $( \gamma )$ based on equations 2 and 3 from the original paper. Specifically, the best values for EfficientNet-B0 are found to be $( \alpha = 1.2 )$, $( \beta = 1.1 )$, and $( \gamma = 1.15 )$ under the constraint:</p>
<p>$$<br>
\alpha \cdot \beta^2 \cdot \gamma^2 \approx 2
$$</p>
<h5 id="step-2-compound-scaling">Step 2: Compound Scaling<a hidden class="anchor" aria-hidden="true" href="#step-2-compound-scaling">#</a></h5>
<p>Fix $( \alpha )$, $( \beta )$, and $( \gamma )$ as constants and scale up the baseline network with different $( \phi )$ values using the equation:</p>
<p>$$<br>
\text{New Depth} = \alpha^\phi \times \text{Baseline Depth}
$$</p>
<p>$$<br>
\text{New Width} = \beta^\phi \times \text{Baseline Width}
$$</p>
<p>$$<br>
\text{New Resolution} = \gamma^\phi \times \text{Baseline Resolution}
$$</p>
<p>This method is used to obtain <strong>EfficientNet-B1 up to B7</strong> models.</p>
<h3 id="efficientnet-architecture">EfficientNet Architecture<a hidden class="anchor" aria-hidden="true" href="#efficientnet-architecture">#</a></h3>
<p>EfficientNet uses <strong>Mobile Inverted Bottleneck (MBConv) layers</strong>, which combine depth-wise separable convolutions and inverted residual blocks. This architecture helps achieve high performance with fewer resources.</p>
<ul>
<li><strong>Inverted Residual Blocks(aka MBConv Block) Layers:</strong> EfficientNet uses these layers for efficient feature extraction.</li>
<li><strong>Compound Scaling:</strong> Scales width, depth, and resolution uniformly.</li>
</ul>
<p>Inside an <strong>Inverted Residual Block</strong>:</p>
<ol>
<li><strong>1x1 Convolution (Expansion)</strong>: Expands the number of channels.</li>
<li><strong>Depthwise Convolution</strong>: Applies lightweight filters to each channel independently.</li>
<li><strong>Squeeze-and-Excitation (SE)</strong>: Assigns importance weights to each channel.</li>
<li><strong>1x1 Convolution (Projection)</strong>: Reduces the number of channels back to the original size.</li>
<li><strong>Residual Connection</strong>: Adds the original input back to the output.</li>
</ol>
<p><img loading="lazy" src="/posts/effnet/img3.png" alt="EfficientNetArch"  />
</p>
<p>EfficientNet models have <strong>set new benchmarks for accuracy while being more resource-efficient than previous models</strong>. They are widely used for various computer vision tasks due to their balanced approach to scaling.
Their architectures, such as <strong>EfficientNet-B0 up to EfficientNet-B7</strong>, provide a range of options depending on the
<strong>required accuracy and available computational resources</strong>.
<img loading="lazy" src="/posts/effnet/img2.png" alt="EfficientNetArch"  />
</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://adilsarsenov.dev/tags/deep-learning/">Deep Learning</a></li>
      <li><a href="https://adilsarsenov.dev/tags/neural-networks/">Neural Networks</a></li>
      <li><a href="https://adilsarsenov.dev/tags/cnn/">CNN</a></li>
      <li><a href="https://adilsarsenov.dev/tags/efficientnet/">EfficientNet</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://adilsarsenov.dev/">ASR</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>

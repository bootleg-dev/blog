[{"content":"Introduction In the realm of machine learning and computer vision, evaluating model performance is as critical as designing and training the models themselves. Metrics provide quantifiable measures to assess the effectiveness and accuracy of models, guiding decisions for improvement and deployment. This article explores key metrics used in machine learning, with a focus on computer vision applications. We\u0026rsquo;ll delve into their definitions, significance, practical implementation, and simple examples for clarity.\nClassification Metrics Accuracy Accuracy is the most straightforward metric, representing the ratio of correctly predicted instances to the total instances.\n$$ \\text{Accuracy} = \\frac{\\text{True Positives} + \\text{True Negatives}}{\\text{Total Instances}} $$\nExample Calculation:\nTrue Positives (TP) = 50 True Negatives (TN) = 40 False Positives (FP) = 10 False Negatives (FN) = 0 Total Instances = 100 $$ \\text{Accuracy} = \\frac{50 + 40}{100} = \\frac{90}{100} = 0.90 , \\text{or} , 90\\text{%} $$\nPrecision, Recall, and F1 Score Precision and recall provide deeper insights, especially in imbalanced datasets.\nPrecision: The ratio of true positive predictions to the total predicted positives. $$ \\text{Precision} = \\frac{\\text{True Positives}}{\\text{True Positives} + \\text{False Positives}} $$\nExample Calculation:\nTP = 30 FP = 10 $$ \\text{Precision} = \\frac{30}{30 + 10} = \\frac{30}{40} = 0.75 , \\text{or} , 75\\text{%} $$\nRecall: The ratio of true positive predictions to all actual positives. $$ \\text{Recall} = \\frac{\\text{True Positives}}{\\text{True Positives} + \\text{False Negatives}} $$\nExample Calculation:\nTP = 30 FN = 20 $$ \\text{Recall} = \\frac{30}{30 + 20} = \\frac{30}{50} = 0.60 , \\text{or} , 60\\text{%} $$\nF1 Score: The harmonic mean of precision and recall, balancing both metrics. $$ \\text{F1 Score} = 2 \\cdot \\frac{\\text{Precision} \\cdot \\text{Recall}}{\\text{Precision} + \\text{Recall}} $$\nExample Calculation:\nPrecision = 0.75 Recall = 0.60 $$ \\text{F1 Score} = 2 \\cdot \\frac{0.75 \\cdot 0.60}{0.75 + 0.60} = 2 \\cdot \\frac{0.45}{1.35} = \\frac{0.90}{1.35} = 0.67 , \\text{or} , 67\\text{%} $$\nSpecificity and Sensitivity Specificity: The ratio of true negative predictions to all actual negatives. It is used to measure the ability of the model to correctly identify negative instances. $$ \\text{Specificity} = \\frac{\\text{True Negatives}}{\\text{True Negatives} + \\text{False Positives}} $$\nExample Calculation:\nTN = 70 FP = 10 $$ \\text{Specificity} = \\frac{70}{70 + 10} = \\frac{70}{80} = 0.875 , \\text{or} , 87.5\\text{%} $$\nSensitivity: Also known as recall, it measures the ability of the model to correctly identify positive instances. $$ \\text{Sensitivity} = \\frac{\\text{True Positives}}{\\text{True Positives} + \\text{False Negatives}} $$\nConfusion Matrix A confusion matrix is a table that provides a detailed breakdown of the performance of a classification model. It shows the number of true positive, true negative, false positive, and false negative predictions.\nExample Calculation:\nPredicted Positive Predicted Negative Actual Positive True Positive (TP) = 50 False Negative (FN) = 10 Actual Negative False Positive (FP) = 5 True Negative (TN) = 35 ROC-AUC The Receiver Operating Characteristic (ROC) curve is a graphical representation of a model\u0026rsquo;s ability to discriminate between positive and negative classes across different threshold values. The Area Under the Curve (AUC) quantifies this ability into a single scalar value.\nROC Curve: Plots the true positive rate (recall) against the false positive rate (1 - specificity) at various threshold settings. AUC: The area under the ROC curve, where an AUC of 1 represents a perfect model, and an AUC of 0.5 represents a model with no discrimination capability. Example Calculation: Suppose we have the following TPR and FPR values at different thresholds:\nThreshold TPR (Recall) FPR (1 - Specificity) 0.1 0.95 0.50 0.2 0.90 0.30 0.3 0.85 0.20 0.4 0.80 0.15 0.5 0.75 0.10 Plotting these points on the ROC curve and calculating the area under this curve gives us the AUC.\nLog Loss (Cross-Entropy Loss) Log Loss evaluates the performance of a classification model where the prediction output is a probability value between 0 and 1.\n$$ \\text{Log Loss} = -\\frac{1}{N} \\sum_{i=1}^{N} [y_i \\log(\\hat{y}_i) + (1 - y_i) \\log(1 - \\hat{y}_i)] $$\nExample Calculation:\nSuppose we have 3 instances with the following actual and predicted probabilities: Instance 1: $( y_1 = 1 ), ( \\hat{y}_1 = 0.9 )$ Instance 2: $( y_2 = 0 ), ( \\hat{y}_2 = 0.2 )$ Instance 3: $( y_3 = 1 ), ( \\hat{y}_3 = 0.7 )$ $$ \\text{Log Loss} = -\\frac{1}{3} [(1 \\cdot \\log(0.9) + (1 - 1) \\cdot \\log(1 - 0.9)) + (0 \\cdot \\log(0.2) + (1 - 0) \\cdot \\log(1 - 0.2)) + (1 \\cdot \\log(0.7) + (1 - 1) \\cdot \\log(1 - 0.7))] $$\n$$ \\text{Log Loss} = -\\frac{1}{3} [(-0.105) + (-0.223) + (-0.357)] = -\\frac{1}{3} [-0.685] = 0.228 $$\nMatthews Correlation Coefficient (MCC) MCC is a balanced measure that can be used even if the classes are of very different sizes. It considers true and false positives and negatives.\n$$ \\text{MCC} = \\frac{TP \\cdot TN - FP \\cdot FN}{\\sqrt{(TP + FP)(TP + FN)(TN + FP)(TN + FN)}} $$\nExample Calculation:\nTP = 50, TN = 40, FP = 10, FN = 10 $$ \\text{MCC} = \\frac{(50 \\cdot 40) - (10 \\cdot 10)}{\\sqrt{(50 + 10)(50 + 10)(40 + 10)(40 + 10)}} = \\frac{2000 - 100}{\\sqrt{60 \\cdot 60 \\cdot 50 \\cdot 50}} = \\frac{1900}{150000} = 0.63 $$\nRegression Metrics Mean Absolute Error (MAE) MAE measures the average magnitude of errors in predictions without considering their direction.\n$$ \\text{MAE} = \\frac{1}{n} \\sum_{i=1}^{n} |y_i - \\hat{y}_i| $$\nExample Calculation:\nErrors = [1, 2, 3] $$ \\text{MAE} = \\frac{1 + 2 + 3}{3} = \\frac{6}{3} = 2 $$\nMean Squared Error (MSE) and Root Mean Squared Error (RMSE) MSE squares the errors before averaging, penalizing larger errors more significantly.\n$$ \\text{MSE} = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2 $$\nExample Calculation:\nErrors = [1, 2, 3] $$ \\text{MSE} = \\frac{1^2 + 2^2 + 3^2}{3} = \\frac{1 + 4 + 9}{3} = \\frac{14}{3} \\approx 4.67 $$\nRMSE is the square root of MSE, bringing the units back to the original scale.\n$$ \\text{RMSE} = \\sqrt{\\text{MSE}} $$\nExample Calculation:\nMSE = 4.67 $$ \\text{RMSE} = \\sqrt{4.67} \\approx 2.16 $$\nR-Squared (R²) R-Squared represents the proportion of the variance in the dependent variable that is predictable from the independent variable(s).\n$$ R^2 = 1 - \\frac{\\sum_{i=1}^{n} (y_i - \\hat{y_i})^2}{\\sum_{i=1}^{n} (y_i - \\bar{y})^2} $$\nExample Calculation:\nTotal Sum of Squares (TSS) = 100 Residual Sum of Squares (RSS) = 20 $$ R^2 = 1 - \\frac{20}{100} = 1 - 0.20 = 0.80 , \\text{or} , 80\\text{%} $$\nMean Absolute Percentage Error (MAPE) MAPE measures the average absolute percentage error between predicted and actual values.\n$$ \\text{MAPE} = \\frac{1}{n} \\sum_{i=1}^{n} \\left| \\frac{y_i - \\hat{y}_i}{y_i} \\right| $$\nExample Calculation:\nActual values = [100, 200, 300] Predicted values = [110, 190, 310] $$ \\text{MAPE} = \\frac{1}{3} \\left( \\left| \\frac{100 - 110}{100} \\right| + \\left| \\frac{200 - 190}{200} \\right| + \\left| \\frac{300 - 310}{300} \\right| \\right) = \\frac{1}{3} \\left(0.10 + 0.05 + 0.033\\right) = \\frac{1}{3} \\left(0.183\\right) \\approx 0.061 , \\text{or} , 6.1\\text{%} $$\nExplained Variance Score Explained variance measures how much of the variance in the target variable is explained by the model.\n$$ \\text{Explained Variance} = 1 - \\frac{\\text{Var}(y - \\hat{y})}{\\text{Var}(y)} $$\nExample Calculation:\nVariance of residuals = 20 Variance of target = 100 $$ \\text{Explained Variance} = 1 - \\frac{20}{100} = 1 - 0.20 = 0.80 , \\text{or} , 80\\text{%} $$\nComputer Vision Metrics Intersection over Union (IoU) IoU is crucial for segmentation and object detection tasks, measuring the overlap between the predicted and ground truth bounding boxes or segments.\n$$ \\text{IoU} = \\frac{\\text{Area of Overlap}}{\\text{Area of Union}} $$\nExample Calculation:\nArea of Overlap = 30 Area of Union = 50 $$ \\text{IoU} = \\frac{30}{50} = 0.60 , \\text{or} , 60\\text{%} $$\nMean Average Precision (mAP) mAP is commonly used in object detection, summarizing the precision-recall curve across multiple classes.\nCalculate the precision-recall curve for each class. Compute the Average Precision (AP) for each class. Take the mean of AP values across all classes. Example Calculation:\nAP values for three classes = [0.8, 0.7, 0.9] $$ \\text{mAP} = \\frac{0.8 + 0.7 + 0.9}{3} = \\frac{2.4}{3} = 0.80 , \\text{or} , 80\\text{%} $$\nDice Coefficient The Dice Coefficient, similar to IoU, is another metric for segmentation tasks, focusing on the overlap between predicted and ground truth segments.\n$$ \\text{Dice Coefficient} = \\frac{2 \\times \\text{Area of Overlap}}{\\text{Total Area of Predicted} + \\text{Total Area of Ground Truth}} $$\nExample Calculation:\nArea of Overlap = 30 Total Area of Predicted = 40 Total Area of Ground Truth = 50 $$ \\text{Dice Coefficient} = \\frac{2 \\times 30}{40 + 50} = \\frac{60}{90} = 0.67 , \\text{or} , 67\\text{%} $$\nPixel Accuracy Pixel Accuracy measures the proportion of correctly classified pixels in the entire image.\n$$ \\text{Pixel Accuracy} = \\frac{\\text{Number of Correct Pixels}}{\\text{Total Number of Pixels}} $$\nExample Calculation:\nNumber of Correct Pixels = 900 Total Number of Pixels = 1000 $$ \\text{Pixel Accuracy} = \\frac{900}{1000} = 0.90 , \\text{or} , 90\\text{%} $$\nMean IoU (mIoU) mIoU is the mean of the Intersection over Union (IoU) for all classes. It is commonly used for semantic segmentation tasks.\n$$ \\text{mIoU} = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{\\text{Area of Overlap}}{\\text{Area of Union}} $$\nExample Calculation:\nIoU values for three classes = [0.6, 0.7, 0.8] $$ \\text{mIoU} = \\frac{0.6 + 0.7 + 0.8}{3} = \\frac{2.1}{3} = 0.70 , \\text{or} , 70\\text{%} $$\nStructural Similarity Index (SSIM) SSIM measures the similarity between two images, considering luminance, contrast, and structure.\n$$ \\text{SSIM}(x, y) = \\frac{(2\\mu_x \\mu_y + C_1)(2\\sigma_{xy} + C_2)}{(\\mu_x^2 + \\mu_y^2 + C_1)(\\sigma_x^2 + \\sigma_y^2 + C_2)} $$\nExample Calculation: $$Assume ( \\mu_x = 100 ), ( \\mu_y = 105 ), ( \\sigma_x = 15 ), ( \\sigma_y = 20 ), ( \\sigma_{xy} = 18 ), ( C_1 = 6.5 ), ( C_2 = 58 )$$\n$$ \\text{SSIM} = \\frac{(2 \\cdot 100 \\cdot 105 + 6.5)(2 \\cdot 18 + 58)}{(100^2 + 105^2 + 6.5)(15^2 + 20^2 + 58)} $$\n$$ \\text{SSIM} = \\frac{(21000 + 6.5)(36 + 58)}{(10000 + 11025 + 6.5)(225 + 400 + 58)} $$\n$$ \\text{SSIM} = \\frac{21006.5 \\cdot 94}{21031.5 \\cdot 683} \\approx 0.42 $$\nPractical Implementation Below is a practical implementation of some of these metrics in Python using popular libraries like scikit-learn.\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, confusion_matrix, mean_absolute_error, mean_squared_error, r2_score import numpy as np # Example ground truth and predictions y_true = np.array([0, 1, 0, 1, 1, 0, 1, 1]) y_pred = np.array([0, 1, 0, 0, 1, 0, 1, 0]) y_scores = np.array([0.1, 0.9, 0.2, 0.4, 0.8, 0.1, 0.7, 0.3]) # Classification metrics accuracy = accuracy_score(y_true, y_pred) precision = precision_score(y_true, y_pred) recall = recall_score(y_true, y_pred) f1 = f1_score(y_true, y_pred) roc_auc = roc_auc_score(y_true, y_scores) conf_matrix = confusion_matrix(y_true, y_pred) print(f\u0026#34;Accuracy: {accuracy:.2f}\u0026#34;) print(f\u0026#34;Precision: {precision:.2f}\u0026#34;) print(f\u0026#34;Recall: {recall:.2f}\u0026#34;) print(f\u0026#34;F1 Score: {f1:.2f}\u0026#34;) print(f\u0026#34;ROC AUC: {roc_auc:.2f}\u0026#34;) print(f\u0026#34;Confusion Matrix:\\n{conf_matrix}\u0026#34;) # Regression metrics example y_true_reg = np.array([3.0, -0.5, 2.0, 7.0]) y_pred_reg = np.array([2.5, 0.0, 2.0, 8.0]) mae = mean_absolute_error(y_true_reg, y_pred_reg) mse = mean_squared_error(y_true_reg, y_pred_reg) rmse = np.sqrt(mse) r2 = r2_score(y_true_reg, y_pred_reg) print(f\u0026#34;MAE: {mae:.2f}\u0026#34;) print(f\u0026#34;MSE: {mse:.2f}\u0026#34;) print(f\u0026#34;RMSE: {rmse:.2f}\u0026#34;) print(f\u0026#34;R2 Score: {r2:.2f}\u0026#34;) Summary Metrics are the cornerstone of model evaluation in machine learning and computer vision. By understanding and appropriately applying these metrics, practitioners can gain valuable insights into model performance, guiding improvements and ensuring the deployment of effective models. Whether working on classification, regression, or computer vision tasks, selecting the right metrics is essential for robust and meaningful evaluation.\n","permalink":"https://adilsarsenov.dev/posts/metrics/","summary":"Introduction In the realm of machine learning and computer vision, evaluating model performance is as critical as designing and training the models themselves. Metrics provide quantifiable measures to assess the effectiveness and accuracy of models, guiding decisions for improvement and deployment. This article explores key metrics used in machine learning, with a focus on computer vision applications. We\u0026rsquo;ll delve into their definitions, significance, practical implementation, and simple examples for clarity.","title":"Metrics in Machine Learning and Computer Vision"},{"content":"Introduction Image segmentation is a crucial technique in computer vision, enabling the division of an image into multiple meaningful and homogeneous regions or objects based on their inherent characteristics, such as color, texture, shape, or brightness. This process is fundamental in applications like object recognition, tracking, detection, medical imaging, and robotics. In this article, we delve into two powerful deep learning models for image segmentation: Fully Convolutional Networks (FCN) and U-Net. We will explore their architectures, key concepts, and practical applications, providing insights into their advantages and best practices for implementation.\nFully Convolutional Networks (FCN) Overview Fully Convolutional Networks (FCNs) are a class of neural networks designed specifically for semantic segmentation. Unlike traditional Convolutional Neural Networks (CNNs) that produce a single label for the entire image, FCNs output a segmentation map where each pixel is classified into a particular category.\nArchitecture The architecture of an FCN is based on an encoder-decoder structure:\nEncoder (Downsampling Path): This part of the network extracts complex features from the input image through a series of convolutional and pooling layers. The spatial resolution is reduced while increasing the depth of the feature maps, allowing the network to capture high-level semantic information.\nDecoder (Upsampling Path): The decoder part of the network upscales the reduced-resolution feature maps back to the original image size. This is achieved through transposed convolution layers (also known as deconvolution layers), which learn the appropriate strides and padding to reconstruct the high-resolution segmentation map.\nKey Concepts Pooling (Downsampling): Pooling layers reduce the spatial resolution of the feature maps, which helps in capturing invariant features and reducing computational complexity. Common types include max pooling and average pooling.\nTransposed Convolution (Upsampling): Transposed convolution layers are used to increase the spatial resolution of the feature maps, essentially reversing the effect of pooling layers to reconstruct the detailed segmentation map.\nSkip Connections: To address the loss of spatial information due to pooling, skip connections are introduced. These connections transfer features from the encoder directly to the corresponding decoder layers, enabling the network to recover fine-grained details and produce more accurate segmentation boundaries.\nPractical Implementation Here is a simplified implementation of an FCN using PyTorch:\nimport torch import torch.nn as nn class SimpleFCN(nn.Module): def __init__(self, n_classes): super(SimpleFCN, self).__init__() # Encoder: Downsampling part self.encoder = nn.Sequential( nn.Conv2d(3, 64, kernel_size=3, padding=1), # Conv layer nn.ReLU(), # Activation nn.MaxPool2d(kernel_size=2, stride=2), # Downsampling nn.Conv2d(64, 128, kernel_size=3, padding=1), # Conv layer nn.ReLU(), # Activation nn.MaxPool2d(kernel_size=2, stride=2) # Downsampling ) # Decoder: Upsampling part self.decoder = nn.Sequential( nn.ConvTranspose2d(128, 64, kernel_size=2, stride=2), # Upsampling nn.ReLU(), # Activation nn.ConvTranspose2d(64, n_classes, kernel_size=2, stride=2) # Upsampling to original size ) def forward(self, x): x = self.encoder(x) x = self.decoder(x) return x model = SimpleFCN(n_classes=21) # Example with 21 classes U-Net Overview U-Net is a specialized neural network architecture designed for biomedical image segmentation, introduced by Olaf Ronneberger, Philipp Fischer, and Thomas Brox in 2015. Its distinctive U-shaped design, which features a symmetric encoder-decoder structure, has made it a popular choice in various medical image analysis tasks due to its impressive performance and efficiency.\nArchitecture The U-Net architecture consists of two main parts:\nEncoder (Contraction Path): Similar to FCN, the encoder part of U-Net captures high-level features through a series of convolutional and pooling layers. Each block typically consists of two 3x3 convolution layers followed by a ReLU activation function and a 2x2 max pooling layer.\nDecoder (Expansion Path): The decoder part upscales the feature maps to the original image size using transposed convolutions. At each upsampling step, the decoder concatenates the feature maps from the corresponding encoder layer via skip connections, providing rich contextual information for precise segmentation.\nKey Concepts Skip Connections: By concatenating the feature maps from the encoder to the decoder at each corresponding level, U-Net can leverage both high-level and low-level features, resulting in better localization and segmentation accuracy.\nData Augmentation: Given the often limited availability of annotated data in medical imaging, U-Net heavily relies on data augmentation techniques to enhance the diversity of the training dataset. This includes operations like rotations, flips, and elastic deformations.\nPractical Implementation Here is a simplified implementation of a U-Net using PyTorch:\nimport torch import torch.nn as nn import torch.nn.functional as F class SimpleUNet(nn.Module): def __init__(self, n_classes): super(SimpleUNet, self).__init__() # Encoder (Downsampling) self.enc1 = self.conv_block(3, 64) self.enc2 = self.conv_block(64, 128) self.enc3 = self.conv_block(128, 256) self.enc4 = self.conv_block(256, 512) # Decoder (Upsampling) self.upconv1 = nn.ConvTranspose2d(512, 256, kernel_size=2, stride=2) self.dec1 = self.conv_block(512, 256) # 256 + 256 from skip connection self.upconv2 = nn.ConvTranspose2d(256, 128, kernel_size=2, stride=2) self.dec2 = self.conv_block(256, 128) # 128 + 128 from skip connection self.upconv3 = nn.ConvTranspose2d(128, 64, kernel_size=2, stride=2) self.dec3 = self.conv_block(128, 64) # 64 + 64 from skip connection # Final layer self.final_conv = nn.Conv2d(64, n_classes, kernel_size=1) def conv_block(self, in_channels, out_channels): return nn.Sequential( nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1), nn.ReLU(), nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1), nn.ReLU() ) def forward(self, x): # Encoder enc1 = self.enc1(x) enc2 = self.enc2(F.max_pool2d(enc1, 2)) enc3 = self.enc3(F.max_pool2d(enc2, 2)) enc4 = self.enc4(F.max_pool2d(enc3, 2)) # Decoder with skip connections dec1 = self.upconv1(enc4) dec1 = torch.cat((dec1, enc3), dim=1) # Concatenate skip connection dec1 = self.dec1(dec1) dec2 = self.upconv2(dec1) dec2 = torch.cat((dec2, enc2), dim=1) # Concatenate skip connection dec2 = self.dec2(dec2) dec3 = self.upconv3(dec2) dec3 = torch.cat((dec3, enc1), dim=1) # Concatenate skip connection dec3 = self.dec3(dec3) x = self.final_conv(dec3) return x model = SimpleUNet(n_classes=21) # Example with 21 classes Summary Both FCN and U-Net are powerful architectures for image segmentation tasks. FCN is a more general-purpose segmentation network, while U-Net is specifically designed for biomedical image segmentation with its U-shaped encoder-decoder structure and extensive use of skip connections.\n","permalink":"https://adilsarsenov.dev/posts/fcn_unet/","summary":"Introduction Image segmentation is a crucial technique in computer vision, enabling the division of an image into multiple meaningful and homogeneous regions or objects based on their inherent characteristics, such as color, texture, shape, or brightness. This process is fundamental in applications like object recognition, tracking, detection, medical imaging, and robotics. In this article, we delve into two powerful deep learning models for image segmentation: Fully Convolutional Networks (FCN) and U-Net.","title":"Image Segmentation Techniques: FCN and U-Net"},{"content":"Introduction Transfer learning is a powerful machine learning technique where a model developed for one task is reused as the starting point for a model on a second task. This approach can save significant time and resources, making it a popular choice for many machine learning applications.\nWhat is Transfer Learning? Transfer learning leverages the knowledge gained while solving one problem and applies it to a different but related problem. This method is particularly useful when the amount of data available for the new task is limited.\nPre-trained Model Approach One common approach in transfer learning is to use a pre-trained model. Here\u0026rsquo;s how it works: Step 1: Select Source Model Choose a pre-trained model from available options. Many research institutions release models trained on large and challenging datasets, which can be used as the starting point.\nStep 2: Reuse Model The selected pre-trained model is then reused as the base for the new task. Depending on the specifics of the task, you might use the entire model or just parts of it.\nStep 3: Tune Model Finally, the model is fine-tuned on the new task\u0026rsquo;s data. This tuning process can involve adapting or refining the model based on the input-output pairs available for the new task.\nWhen to Use Transfer Learning? Transfer learning is particularly beneficial in the following scenarios:\nLimited Labeled Data: When there isn\u0026rsquo;t enough labeled training data to train a network from scratch. Similar Tasks: When there already exists a network pre-trained on a similar task, usually trained on massive amounts of data. Same Input: When the input for the new task is similar to the input for the pre-trained model. In general, the benefits of transfer learning may not be obvious until after the model has been developed and evaluated. However, it often enables the development of skillful models that would be challenging to create without it.\nPractical Applications of Transfer Learning Image Classification Transfer learning is widely used in image classification tasks. Pre-trained models like VGG, ResNet, and EfficientNet, which are trained on large datasets like ImageNet, are fine-tuned for specific image classification tasks with smaller datasets.\nObject Detection In object detection, transfer learning helps improve detection accuracy by leveraging pre-trained models. Frameworks like Faster R-CNN and YOLO often use pre-trained backbones to enhance feature extraction.\nNatural Language Processing (NLP) Transfer learning is also prevalent in NLP. Pre-trained language models like BERT, GPT, and T5 are fine-tuned for various NLP tasks such as sentiment analysis, translation, and question answering.\nMedical Image Analysis In medical imaging, transfer learning is used to detect anomalies in MRI scans, CT scans, and X-rays. Pre-trained models are fine-tuned to identify specific medical conditions, aiding in diagnosis and treatment planning.\nSummary Transfer learning is a valuable technique in machine learning, enabling the reuse of existing models to solve new but related problems. By leveraging pre-trained models, transfer learning can significantly reduce the time and resources required to develop high-performing models. Whether in image classification, object detection, NLP, or medical imaging, transfer learning continues to play a crucial role in advancing the field of machine learning.\nStay tuned for more insights on machine learning techniques and their applications in future posts!\n","permalink":"https://adilsarsenov.dev/posts/transfer-learning/","summary":"Introduction Transfer learning is a powerful machine learning technique where a model developed for one task is reused as the starting point for a model on a second task. This approach can save significant time and resources, making it a popular choice for many machine learning applications.\nWhat is Transfer Learning? Transfer learning leverages the knowledge gained while solving one problem and applies it to a different but related problem. This method is particularly useful when the amount of data available for the new task is limited.","title":"Understanding Transfer Learning"},{"content":"Introduction EfficientNet is an advanced deep learning model introduced by Mingxing Tan and Quoc V. Le from Google Research, Brain team, in their paper \u0026ldquo;EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks.\u0026rdquo; EfficientNet solves the common problem of balancing accuracy and resource consumption in deep learning models by using a novel technique called compound scaling.\nWhy EfficientNet? The Challenge of Traditional Models Traditional deep learning models often face a trade-off between accuracy and resource use. Making a model more accurate usually means making it larger, which requires more computational power and memory. EfficientNet tackles this challenge effectively.\nThe Solution: Compound Scaling EfficientNet introduces compound scaling, which scales three critical dimensions of a neural network: width, depth, and resolution. This scaling method ensures that the model is both efficient and accurate.\nWidth Scaling Width scaling refers to the number of channels in each layer of the neural network. Increasing the width helps the model capture more complex patterns and features, leading to improved accuracy. Conversely, decreasing the width results in a more lightweight model suitable for environments with limited resources.\nDepth Scaling Depth scaling involves the total number of layers in the network. Deeper models can capture more intricate data representations but require more computational resources. Shallower models are computationally efficient but might sacrifice accuracy.\nResolution Scaling Resolution scaling adjusts the size of the input images. Higher-resolution images provide more detailed information, potentially improving performance. However, they also need more memory and computational power. Lower-resolution images consume fewer resources but may lose fine-grained details.\nMathematical Explanation of Compound Scaling EfficientNet uses a simple yet effective method to scale up models. The scaling method is guided by a compound coefficient $( \\phi )$ which uniformly scales network width, depth, and resolution:\n$$[ \\text{depth:} \\quad d = \\alpha^\\phi ]$$\n$$[ \\text{width:} \\quad w = \\beta^\\phi ]$$\n$$[ \\text{resolution:} \\quad r = \\gamma^\\phi ]$$\nwhere $( \\alpha )$, $( \\beta )$, and $( \\gamma )$ are constants determined through a small grid search and $( \\phi )$ is a user-specified coefficient that controls how much to scale each dimension. The idea is to balance all three dimensions rather than scaling one aspect alone.\nGrid Search for EfficientNet The process of determining the constants $( \\alpha )$, $( \\beta )$, and $( \\gamma )$ involves two main steps:\nStep 1: Baseline Network Assume twice the resources are available and set $( \\phi = 1 )$. Perform a small grid search for $( \\alpha )$, $( \\beta )$, and $( \\gamma )$ based on equations 2 and 3 from the original paper. Specifically, the best values for EfficientNet-B0 are found to be $( \\alpha = 1.2 )$, $( \\beta = 1.1 )$, and $( \\gamma = 1.15 )$ under the constraint:\n$$[ \\alpha \\cdot \\beta^2 \\cdot \\gamma^2 \\approx 2 ]$$\nStep 2: Compound Scaling Fix $( \\alpha )$, $( \\beta )$, and $( \\gamma )$ as constants and scale up the baseline network with different $( \\phi )$ values using the equation:\n$$[ \\text{New Depth} = \\alpha^\\phi \\times \\text{Baseline Depth} ]$$\n$$[ \\text{New Width} = \\beta^\\phi \\times \\text{Baseline Width} ]$$\n$$[ \\text{New Resolution} = \\gamma^\\phi \\times \\text{Baseline Resolution} ]$$\nThis method is used to obtain EfficientNet-B1 to B7 models.\nEfficientNet Architecture EfficientNet uses Mobile Inverted Bottleneck (MBConv) layers, which combine depth-wise separable convolutions and inverted residual blocks. This architecture helps achieve high performance with fewer resources.\nKey Components MBConv Layers: EfficientNet uses these layers for efficient feature extraction. Compound Scaling: Scales width, depth, and resolution uniformly. Inverted Residual Blocks: Help in maintaining efficiency and performance. Achievements of EfficientNet EfficientNet models have set new benchmarks for accuracy while being more resource-efficient than previous models. They are widely used for various computer vision tasks due to their balanced approach to scaling.\nPractical Applications of EfficientNet Image Classification EfficientNet models are highly effective for image classification tasks. Their architectures, such as EfficientNet-B0 to EfficientNet-B7, provide a range of options depending on the required accuracy and available computational resources.\nObject Detection EfficientNet serves as a backbone for many object detection frameworks, offering robust feature extraction capabilities that enhance detection accuracy.\nMedical Image Analysis EfficientNet models are used in medical imaging to detect anomalies in MRI scans, CT scans, and X-rays, aiding in diagnosis and treatment planning.\nTransfer Learning EfficientNet\u0026rsquo;s pre-trained models are often used for transfer learning. A model trained on a large dataset like ImageNet can be fine-tuned for specific tasks with smaller datasets, significantly reducing training time and improving performance.\nSummary EfficientNet\u0026rsquo;s innovative architecture has revolutionized deep learning by providing a method to balance model accuracy and resource efficiency. Its success in practical applications highlights its robustness and versatility. By introducing compound scaling, EfficientNet addresses significant challenges associated with traditional deep learning models, paving the way for further advancements in neural network design.\n","permalink":"https://adilsarsenov.dev/posts/effnet/","summary":"Introduction EfficientNet is an advanced deep learning model introduced by Mingxing Tan and Quoc V. Le from Google Research, Brain team, in their paper \u0026ldquo;EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks.\u0026rdquo; EfficientNet solves the common problem of balancing accuracy and resource consumption in deep learning models by using a novel technique called compound scaling.\nWhy EfficientNet? The Challenge of Traditional Models Traditional deep learning models often face a trade-off between accuracy and resource use.","title":"Understanding EfficientNet"},{"content":"Introduction ResNet, which stands for Residual Network, is a revolutionary deep learning model created by Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun in their 2015 paper \u0026ldquo;Deep Residual Learning for Image Recognition.\u0026rdquo; ResNet tackles big challenges in training very deep neural networks, like the vanishing gradient problem, and has achieved amazing results in various computer vision tasks.\nWhy ResNet? The Need for Deeper Networks Traditional Convolutional Neural Networks (CNNs) face performance issues when the network depth increases. This isn\u0026rsquo;t because of overfitting but rather an optimization challenge where adding more layers makes the network harder to train effectively.\nThe Vanishing Gradient Problem When neural networks get deeper, the gradients used to update weights during backpropagation become very small, leading to negligible updates. This is known as the vanishing gradient problem and it makes training very deep networks difficult.\nThe Solution: Residual Blocks ResNet introduces residual learning through residual blocks. Instead of expecting each layer to directly fit a desired mapping, residual blocks allow layers to fit a residual mapping. It\u0026rsquo;s easier to optimize the residual mapping than the original, unreferenced mapping.\nResidual Block Structure A typical residual block in ResNet has two or more convolutional layers followed by batch normalization and ReLU activation. The input to the block is added directly to the output of the stacked layers (this addition is the \u0026ldquo;shortcut connection\u0026rdquo;), creating a residual connection.\nMathematical Representation If the input is $ ( x ) $ and the desired output is $( H(x) ) $, a residual block models this as: $[ H(x) = F(x, {W_i}) + x ]$ where $ ( F(x, {W_i}) ) $ represents the residual mapping to be learned.\nResNet Architecture ResNet architectures come in various depths, such as ResNet-18, ResNet-34, ResNet-50, ResNet-101, and ResNet-152, indicating the number of layers. These architectures stack residual blocks to create deep networks that can effectively learn complex features.\nKey Components Convolutional Layers: Extract features from the input image. Batch Normalization: Normalizes the output of each convolutional layer, stabilizing and accelerating training. ReLU Activation: Introduces non-linearity. Residual Connections: Add the input of the block to the output, allowing the network to learn residual mappings. Achievements of ResNet ResNet won first place in the ILSVRC 2015 classification competition with a top-5 error rate of 3.57% using an ensemble model. It also won first place in the ImageNet Detection, ImageNet Localization, COCO Detection, and COCO Segmentation tasks in the ILSVRC and COCO 2015 competitions. Notably, replacing VGG-16 layers in Faster R-CNN with ResNet-101 layers led to a 28% relative improvement.\nPractical Applications of ResNet Image Classification ResNet is widely used for image classification tasks due to its ability to train very deep networks without degradation. Its architectures, such as ResNet-50 and ResNet-101, are standard benchmarks in the field.\nObject Detection ResNet serves as the backbone for many object detection frameworks like Faster R-CNN and Mask R-CNN, providing robust feature extraction capabilities that enhance detection accuracy.\nMedical Image Analysis In medical imaging, ResNet models are employed to detect anomalies in MRI scans, CT scans, and X-rays, aiding in diagnosis and treatment planning.\nTransfer Learning ResNet\u0026rsquo;s pre-trained models are often used for transfer learning, where a model trained on a large dataset like ImageNet is fine-tuned for specific tasks with smaller datasets. This approach significantly reduces training time and improves performance.\nSummary ResNet\u0026rsquo;s innovative architecture has transformed deep learning by enabling the training of very deep networks. Its success in competitions and practical applications highlights its robustness and versatility. By introducing residual connections, ResNet overcomes significant challenges associated with deep networks, paving the way for further advancements in neural network design.\n","permalink":"https://adilsarsenov.dev/posts/resnet/","summary":"Introduction ResNet, which stands for Residual Network, is a revolutionary deep learning model created by Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun in their 2015 paper \u0026ldquo;Deep Residual Learning for Image Recognition.\u0026rdquo; ResNet tackles big challenges in training very deep neural networks, like the vanishing gradient problem, and has achieved amazing results in various computer vision tasks.\nWhy ResNet? The Need for Deeper Networks Traditional Convolutional Neural Networks (CNNs) face performance issues when the network depth increases.","title":"Understanding ResNet"},{"content":"Introduction The VGG (Visual Geometry Group) network is a renowned deep learning model known for its simplicity and effectiveness in image recognition tasks. Developed by K. Simonyan and A. Zisserman from Oxford University, the VGG network significantly advanced the field of computer vision and performed remarkably in the ILSVRC-2014 competition.\nVGG Architecture VGG networks are characterized by their deep architecture, which involves stacking multiple convolutional layers. The two most commonly used versions are VGG-16 and VGG-19, featuring 16 and 19 layers, respectively.\nKey Components of VGG Fixed Size Input: The network accepts a fixed size of (224 x 224) RGB images. Preprocessing: The only preprocessing step involves subtracting the mean RGB value from each pixel, computed over the entire training set (ImageNet). Kernel Size: VGG uses a small receptive field of 3x3 kernels with a stride of 1. Max-Pooling: Performed over a 2x2 pixel window with a stride of 2. Fully Connected Layers: VGG has three fully connected layers. The first two layers have 4096 neurons each, and the final layer has 1000 neurons, corresponding to the 1000 classes in the ImageNet dataset. Activation: Uses ReLU (Rectified Linear Unit) to introduce non-linearity. VGG-16 vs. VGG-19 The primary difference between VGG-16 and VGG-19 lies in the number of layers:\nVGG-16: Comprises 13 convolutional layers and 3 fully connected layers, making it slightly less complex and faster to train compared to VGG-19. VGG-19: Contains 16 convolutional layers and 3 fully connected layers, offering slightly better accuracy at the cost of increased computational resources and training time. Both models have demonstrated high accuracy in various benchmarks, but the choice between them depends on the specific application and the available computational resources.\nAchievements of VGG The VGG-16 model achieved a test accuracy of 92.7% on the ImageNet dataset, which includes over 14 million images across 1000 categories. This performance made it one of the top models in the ILSVRC-2014 competition.\nSummary VGG\u0026rsquo;s legacy as a pioneering deep CNN architecture continues to shape the landscape of computer vision. Its depth, simplicity, and effectiveness have made it a valuable tool for researchers and practitioners alike. As the field progresses, VGG\u0026rsquo;s contributions serve as a reminder of the power of deep learning to unlock the secrets hidden within images.\n","permalink":"https://adilsarsenov.dev/posts/vgg/","summary":"Introduction The VGG (Visual Geometry Group) network is a renowned deep learning model known for its simplicity and effectiveness in image recognition tasks. Developed by K. Simonyan and A. Zisserman from Oxford University, the VGG network significantly advanced the field of computer vision and performed remarkably in the ILSVRC-2014 competition.\nVGG Architecture VGG networks are characterized by their deep architecture, which involves stacking multiple convolutional layers. The two most commonly used versions are VGG-16 and VGG-19, featuring 16 and 19 layers, respectively.","title":"Visual Geometry Group - VGG Architecture"},{"content":"Understanding Convolutional Neural Networks (CNNs) Introduction Convolutional Neural Networks (CNNs) are a class of deep learning models designed to process visual data. They have revolutionized computer vision, enabling applications like image classification, object detection, and facial recognition. CNNs mimic the way the human brain processes visual information, making them incredibly powerful for visual tasks.\nKey Concepts in CNNs Convolution Operation Convolutional Layer: The primary building block of a CNN, responsible for feature extraction. Filter (Kernel): A small matrix that slides over the input image, performing multiplications and summations to produce a feature map. Feature Map (Activation Map): The result of the convolution operation, highlighting important features such as edges, textures, and patterns. Activation Function ReLU (Rectified Linear Unit): Introduces non-linearity to the model. It replaces negative values with zero, allowing the network to learn complex patterns. $$ \\text{ReLU}(x) = \\max(0, x) $$\nPooling Layer Max-Pooling: Reduces the spatial dimensions of the feature map while retaining the most important information by selecting the maximum value within each window. Purpose: Reduces computational complexity and helps the network become invariant to small translations of the input image. Flattening Flatten Layer: Converts the 2D pooled feature maps into a 1D vector for the fully connected layers. Purpose: Prepares the data for final classification or regression tasks. Fully Connected Layer Dense Layer: Connects every neuron in one layer to every neuron in the next layer. Purpose: Combines the extracted features to make final decisions. Detailed Explanation of CNN Components Convolutional Layer The convolutional layer applies filters to the input image to extract features like edges and textures.\nFormula: $$ (I * K)(i, j) = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} I(i + m, j + n) K(m, n) $$\n$( I )$: Input image $( K )$: Kernel (filter) $( (i, j) )$: Coordinates in the output feature map $( M, N )$: Dimensions of the kernel This operation allows the network to learn spatial hierarchies of features automatically from low-level to high-level.\nUnderstanding Hyperparameters Kernel Size: Dimensions of the filter (e.g., 3x3, 5x5). Affects the amount of detail the filter can capture. Stride: Step size of the filter movement. Larger strides reduce the output size but increase computational efficiency. Padding: Adds zeros around the input image to maintain the output size. \u0026ldquo;Valid\u0026rdquo; means no padding, \u0026ldquo;same\u0026rdquo; keeps the output size the same as the input. Non-Linearity (ReLU) ReLU introduces non-linearity to help the network learn complex patterns.\n$$ \\text{ReLU}(x) = \\begin{cases} x \u0026amp; \\text{if } x \u0026gt; 0 \\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} $$\nBy setting negative values to zero, ReLU prevents the network from simply becoming a linear classifier.\nPooling Layers Max-pooling reduces the spatial dimensions by selecting the maximum value in each window, effectively down-sampling the feature map.\nFormula: $$ Y(i, j) = \\max_{m,n} X(i \\cdot s + m, j \\cdot s + n) $$\n$( X )$: Input feature map $( Y )$: Output feature map $( s )$: Stride $( m, n )$: Window dimensions Pooling helps in reducing the complexity of the network and prevents overfitting.\nFully Connected Layer Fully connected layers make final decisions using the features extracted by the previous layers.\nFormula: $$ y = f(W \\cdot x + b) $$\n$( W )$: Weight matrix $( x )$: Input vector $( b )$: Bias vector $( f )$: Activation function The fully connected layer combines the high-level features learned by the convolutional layers to output a final prediction.\nOutput Layer The output layer is typically a softmax layer in classification tasks. The softmax function converts the raw output scores into probabilities.\nSoftmax Function: $$ \\sigma(z_i) = \\frac{e^{z_i}}{\\sum_{j=1}^K e^{z_j}} $$\n$( z_i )$: The (i)-th element of the input vector $(z)$ $( K )$: Number of classes The softmax function ensures that the output probabilities sum to 1, making it easier to interpret the results as the likelihood of each class.\nExample CNN Architecture Here’s a simple CNN architecture for image classification:\nInput Layer: 224x224 RGB image Convolutional Layer: 32 filters of size 3x3, stride 1, ReLU activation Max-Pooling Layer: 2x2 window, stride 2 Convolutional Layer: 64 filters of size 3x3, stride 1, ReLU activation Max-Pooling Layer: 2x2 window, stride 2 Flatten Layer: Converts the feature maps into a 1D vector Fully Connected Layer: 128 neurons, ReLU activation Output Layer: Softmax activation for classification into multiple classes This example illustrates the typical workflow in a CNN, from input to final classification.\nApplications of CNNs CNNs have a wide range of applications, including:\nImage Classification: Identifying objects within an image (e.g., cats vs. dogs). Object Detection: Detecting and localizing objects in an image. Semantic Segmentation: Classifying each pixel of an image into different categories. Facial Recognition: Identifying and verifying individuals based on facial features. Medical Image Analysis: Detecting anomalies in medical scans, such as tumors in MRI images. By understanding these components and their functions, you can appreciate the power and versatility of CNNs in solving complex visual tasks.\n","permalink":"https://adilsarsenov.dev/posts/convolutional-neural-networks/","summary":"Understanding Convolutional Neural Networks (CNNs) Introduction Convolutional Neural Networks (CNNs) are a class of deep learning models designed to process visual data. They have revolutionized computer vision, enabling applications like image classification, object detection, and facial recognition. CNNs mimic the way the human brain processes visual information, making them incredibly powerful for visual tasks.\nKey Concepts in CNNs Convolution Operation Convolutional Layer: The primary building block of a CNN, responsible for feature extraction.","title":"Convolutional Neural Networks - CNNs"}]